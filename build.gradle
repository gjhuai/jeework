buildscript {
    def localMavenRepo = new File('d:/repo').toURL().toString()
    repositories {
        mavenRepo url: localMavenRepo
        maven { url 'http://10.229.14.10:8080/nexus/content/groups/public' }
        maven { url 'http://repository.primefaces.org' }
    }
    dependencies {
        //classpath 'org.springframework.build.gradle:docbook-reference-plugin:0.1.3'
    }
}

configure(allprojects) {
    apply plugin: 'java'
    apply plugin: 'maven'
    apply plugin: 'eclipse'
    apply plugin: 'eclipse-wtp'
    apply plugin: 'idea'

    group = 'org.jeework'

    sourceCompatibility=1.6
    targetCompatibility=1.6

    slf4jLog4jVersion = '1.6.1'
    //project.ext["slf4jLog4jVersion"] = '1.5.10'
    
    def localMavenRepo = new File('d:/repo').toURL().toString()

    configurations {
        provided
        testCompile.extendsFrom provided
        compile.transitive = true
    }

    [compileJava, compileTestJava]*.options*.compilerArgs = ['-Xlint:none']
    [compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

    //sourceSets.test.resources.srcDirs = ['src/test/resources', 'src/test/java']
    sourceSets.main.compileClasspath += configurations.provided

    test.systemProperty("java.awt.headless", "true")
	
	eclipse {
		classpath {
			//customizing the classes output directory:
			defaultOutputDir = file('build/classes/main')
			//default settings for dependencies sources/javadoc download:
			downloadSources = false
			downloadJavadoc = false
		}
    }
    
    repositories {
        mavenRepo url: localMavenRepo
        maven { url 'http://10.229.14.10:8080/nexus/content/groups/public' }
        maven { url 'http://repository.primefaces.org' }
    }

    dependencies {
		compile("commons-lang:commons-lang:2.6")
        compile "commons-codec:commons-codec:1.5"
        compile "commons-collections:commons-collections:3.2.1"
 		compile "commons-configuration:commons-configuration:1.7"
		compile "commons-fileupload:commons-fileupload:1.2.1"
		compile "commons-io:commons-io:1.4"
		compile "commons-beanutils:commons-beanutils:1.8.0"
		compile "commons-digester:commons-digester:1.7"
		compile "com.google.guava:guava:r09"
        compile "hirondelle:date4j:1.2.0"
		compile "com.cedarsoft.serialization:jdom:1.0.3"
		compile "ch.qos.cal10n:cal10n-api:0.7.4"
		compile "rapid:xsqlbuilder:1.0.4"
        
        compile "com.alibaba:fastjson:1.1.15"
        compile "org.apache.poi:poi:3.6"

        compile "javax:javaee-api:6.0"
        compile "javax.faces:jsf-api:2.0"
        compile "org.primefaces:primefaces:3.1.1"
		
		compile "org.slf4j:slf4j-api:${slf4jLog4jVersion}"
		compile "org.slf4j:slf4j-ext:${slf4jLog4jVersion}"
		compile "org.slf4j:slf4j-log4j12:${slf4jLog4jVersion}"

        testCompile "junit:junit:4.9"
        //testCompile "org.easymock:easymock:2.5.1"
        //testCompile "org.hamcrest:hamcrest-all:1.1"
        //testCompile "org.jboss.arquillian.junit:arquillian-junit-container:1.0.0.CR5"
    }

    // servlet-api (2.5) and tomcat-servlet-api (3.0) classpath entries should not be
    // exported to dependent projects in Eclipse to avoid false compilation errors due
    // to changing APIs across these versions
	    
    eclipse.classpath.file.whenMerged { classpath ->
        classpath.entries.findAll { entry -> entry.path.contains('javaee-api') }*.exported = false
        classpath.entries.findAll { entry -> entry.path.contains('jsf-api') }*.exported = false
    }
    
    
}

configure(subprojects) { subproject ->
    
    //apply from: "${rootProject.projectDir}/publish-maven.gradle"

    jar {
        manifest.attributes['Implementation-Title'] = subproject.name
        manifest.attributes['Implementation-Version'] = subproject.version

        from("${rootProject.projectDir}/src/dist") {
            include "license.txt"
            include "notice.txt"
            into "META-INF"
            expand(copyright: new Date().format('yyyy'), version: project.version)
        }
    }
    
    javadoc {
        options.memberLevel = org.gradle.external.javadoc.JavadocMemberLevel.PROTECTED
        options.author = true
        options.header = project.name
        options.encoding = 'UTF-8'
        //options.overview = "${projectDir}/src/main/java/overview.html"
    }

    task sourcesJar(type: Jar, dependsOn:classes) {
        classifier = 'sources'
        from sourceSets.main.allJava
    }

    task javadocJar(type: Jar) {
        classifier = 'javadoc'
        from javadoc
    }

    artifacts {
        archives sourcesJar
        archives javadocJar
    }
}


project('jeework-core') {
    description = 'Jeework Core'
    dependencies {

    }
}

project('jeework-security') {
    description = 'Jeework Security'
    dependencies {
        compile project(":jeework-core")
		compile "org.apache.shiro:shiro-core:1.2.0"
		compile "org.apache.shiro:shiro-web:1.2.0"
		compile "org.apache.shiro:shiro-ehcache:1.2.0-SNAPSHOT"
		compile "org.apache.shiro:shiro-faces:2.0-SNAPSHOT"
        compile "com.wcs.cas:casclient:3.2.0"
    }
}

project('jeework-report') {
    description = 'Jeework Report'
    dependencies {
        compile project(":jeework-core")
        compile project(":jeework-security")
        compile "net.sf.jasperreports:jasperreports:4.0.2"
		compile "velocity:velocity:1.5"
        compile "velocity:velocity-dep:1.5"
    }
}

project('jeework-showcase') {
	apply plugin: 'war'
    //apply plugin: 'eclipse-wtp'
	
    description = 'Jeework Showcase'
    dependencies {
        compile project(":jeework-core")
        compile project(":jeework-security")
        compile project(":jeework-report")
    }
}

project("jeework-generator") {
    description = 'Jeework Generator'
    asmVersion = '2.2.3'

    configurations {
        asm
        jarjar
    }
    dependencies {
        //asm "asm:asm:${asmVersion}@jar", "asm:asm-commons:${asmVersion}@jar"
        //jarjar 'com.googlecode.jarjar:jarjar:1.1'
    }

/*
    task repackageAsm(type: Jar) { jar ->
        jar.baseName = "asm-repack"
        jar.version = asmVersion

        doLast() {
            project.ant {
                taskdef name: "jarjar", classname: "com.tonicsystems.jarjar.JarJarTask",
                    classpath: configurations.jarjar.asPath
                jarjar(destfile: archivePath, index: "true", filesetmanifest: "merge") {
                    configurations.asm.each { jarfile ->
                        zipfileset(src: jarfile)
                    }
                    rule(pattern: 'org.objectweb.asm.**', result: 'org.springframework.asm.@1')
                }
            }
        }
    }

    jar {
        dependsOn repackageAsm
        from(zipTree(repackageAsm.archivePath)) {
            exclude 'META-INF/INDEX.LIST'
        }
    }
    */
}

configure(rootProject) {
    description = 'Jee Work'

    //apply plugin: 'docbook-reference'
/*
    reference {
        sourceDir = file('src/reference/docbook')
    }
*/

    // don't publish the default jar for the root project
    configurations.archives.artifacts.clear()

    dependencies { // for integration tests
        //testCompile project(":spring-test")
        //testCompile "javax.servlet:servlet-api:2.5"
    }

    task api(type: Javadoc) {
        group = 'Documentation'
        description = 'Generates aggregated Javadoc API documentation.'
        title = "${rootProject.description} ${version} API"
        options.memberLevel = org.gradle.external.javadoc.JavadocMemberLevel.PROTECTED
        options.encoding = 'UTF-8'
        options.author = true
        options.header = rootProject.description
        //options.overview = 'src/api/overview.html'
        options.links(
            'http://docs.jboss.org/jbossas/javadoc/4.0.5/connector'
        )
        source subprojects.collect { project ->
            project.sourceSets.main.allJava
        }
        destinationDir = new File(buildDir, "api")
        classpath = files(subprojects.collect { project ->
            project.sourceSets.main.compileClasspath
        })
        maxMemory = '1024m'
    }

    task docsZip(type: Zip) {
        group = 'Distribution'
        classifier = 'docs'
        description = "Builds -${classifier} archive containing api and reference " +
            "for deployment at static.springframework.org/spring-framework/docs."

        from('src/dist') {
            include 'changelog.txt'
        }

        from (api) {
            into 'api'
        }
/*
        from (reference) {
            into 'reference'
        }
        */
    }

    task schemaZip(type: Zip) {
        group = 'Distribution'
        classifier = 'schema'
        description = "Builds -${classifier} archive containing all " +
            "XSDs for deployment at static.springframework.org/schema."

        subprojects.each { subproject ->
            def Properties schemas = new Properties();

            subproject.sourceSets.main.resources.find {
                it.path.endsWith('META-INF/spring.schemas')
            }?.withInputStream { schemas.load(it) }

            for (def key : schemas.keySet()) {
                def shortName = key.replaceAll(/http.*schema.(.*).spring-.*/, '$1')
                assert shortName != key
                File xsdFile = subproject.sourceSets.main.resources.find {
                    it.path.endsWith(schemas.get(key))
                }
                assert xsdFile != null
                into (shortName) {
                    from xsdFile.path
                }
            }
        }
    }

    task distZip(type: Zip, dependsOn: [docsZip, schemaZip]) {
        group = 'Distribution'
        classifier = 'dist'
        description = "Builds -${classifier} archive, containing all jars and docs, " +
                      "suitable for community download page."

        baseDir = "${project.name}-${project.version}"
        //project.ext["baseDir"] = "${project.name}-${project.version}";

        from('src/dist') {
            include 'readme.txt'
            include 'license.txt'
            include 'notice.txt'
            into "${baseDir}"
            expand(copyright: new Date().format('yyyy'), version: project.version)
        }

        from(zipTree(docsZip.archivePath)) {
            into "${baseDir}/docs"
        }

        from(zipTree(schemaZip.archivePath)) {
            into "${baseDir}/schema"
        }

        subprojects.each { subproject ->
            into ("${baseDir}/libs") {
                from subproject.jar
                if (subproject.tasks.findByPath('sourcesJar')) {
                    from subproject.sourcesJar
                }
                if (subproject.tasks.findByPath('javadocJar')) {
                    from subproject.javadocJar
                }
            }
        }
    }

    artifacts {
        archives docsZip
        archives schemaZip
        archives distZip
    }

    task wrapper(type: Wrapper) {
        description = 'Generates gradlew[.bat] scripts'
        gradleVersion = '1.0-milestone-9'
    }
}

